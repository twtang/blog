<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="TW">
<meta name="dcterms.date" content="2025-03-29">

<title>Q4. Expection-Maximization Algorithm (8 points) – Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Q4. Expection-Maximization Algorithm (8 points)</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>TW </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 29, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="q4.-expectation-maximization-algorithm-8-points" class="level1">
<h1>Q4. Expectation-Maximization Algorithm (8 points)</h1>
<p>In this question, you are required to code by yourself to complete the EM algorithm.</p>
<section id="data-descriptions" class="level3">
<h3 class="anchored" data-anchor-id="data-descriptions">Data Descriptions:</h3>
<ol type="1">
<li>The data is in Data_Q4.csv.</li>
<li>The test dataset is shown in Q4_Data.csv. There are 6 attributes, which are ‘A’,‘B’,…,‘F’, and totally 626 instances in the dataset. You need to cluster all the instances into two classes. Assume the initial centers are c1=(0,0,0,0,0,0) and c2=(1,1,1,1,1,1).</li>
</ol>
</section>
<section id="requirements" class="level3">
<h3 class="anchored" data-anchor-id="requirements">REQUIREMENTS:</h3>
<ol type="1">
<li>Report the updated centers and SSE for the first two iterations.</li>
<li>Report the overall iteration step when your algorithm terminates.</li>
<li>Report the final converged centers for each cluster.</li>
</ol>
</section>
<section id="submissions" class="level3">
<h3 class="anchored" data-anchor-id="submissions">Submissions:</h3>
<ol type="1">
<li>Put all reports in Q4_readme.pdf.</li>
<li>Submit your source code in folder Q4_code.</li>
<li>Put files/folder above in folder Q4.</li>
</ol>
</section>
<section id="notes" class="level3">
<h3 class="anchored" data-anchor-id="notes">NOTES:</h3>
<p>Please use the terminate condition below:</p>
<p><strong>Terminate condition: the EM algorithm will terminate when:</strong> 1. The sum of L1-distance for each dimension of old-new center [ <em>{} ||C</em>{} - C_{}||_1 ] is smaller than 0.0001, <strong>or</strong> 2. The iteration step is greater than the maximum iteration step 100.</p>
<p>Let’s tackle Q4, which involves implementing the Expectation-Maximization (EM) algorithm for clustering a dataset provided in <code>Data_Q4.csv</code>. The dataset contains 626 instances with 6 attributes, and we need to cluster them into two clusters (c1 and c2) with specific initial centers. We’ll report the updated centers and Sum of Squared Errors (SSE) for the first two iterations, the final centers when the algorithm converges, and submit the code and report in a folder named <code>Q4</code>. Let’s break this down step by step.</p>
<hr>
</section>
<section id="step-1-understanding-the-problem-and-data" class="level3">
<h3 class="anchored" data-anchor-id="step-1-understanding-the-problem-and-data">Step 1: Understanding the Problem and Data</h3>
<ul>
<li><strong>Data Description</strong>:
<ul>
<li><code>Data_Q4.csv</code>: Contains 626 instances with 6 attributes (numerical features).</li>
<li>We need to cluster the data into 2 clusters: c1 and c2.</li>
<li>Initial centers are given:
<ul>
<li>c1 = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0)</li>
<li>c2 = (1.1, 1.1, 1.1, 1.1, 1.1, 1.1)</li>
</ul></li>
</ul></li>
<li><strong>Task</strong>:
<ul>
<li>Implement the EM algorithm for clustering (though this is more akin to Gaussian Mixture Models, the problem seems to describe a k-means-like EM approach with hard assignments).</li>
<li>Report the updated centers and SSE for the first two iterations.</li>
<li>Report the final centers when the algorithm converges.</li>
<li>Submit the code and report in a folder named <code>Q4</code>.</li>
</ul></li>
<li><strong>Termination Conditions</strong>:
<ul>
<li>The sum of L1-distance between old and new centers for each cluster is smaller than 0.0001, i.e., (<em>{} ||C</em>{} - C_{}||_1 &lt; 0.0001).</li>
<li>The iteration step exceeds the maximum of 100 iterations.</li>
</ul></li>
</ul>
<section id="em-algorithm-for-clustering" class="level4">
<h4 class="anchored" data-anchor-id="em-algorithm-for-clustering">EM Algorithm for Clustering</h4>
<p>The EM algorithm is typically used for Gaussian Mixture Models (GMMs), where it iteratively estimates the parameters (means, covariances, and mixing coefficients) of the mixture components. However, the problem description (hard assignments to clusters, L1-distance for convergence, and SSE as a metric) suggests a k-means-like approach with EM terminology. In k-means, the “E-step” assigns points to the nearest cluster, and the “M-step” updates the cluster centers as the mean of assigned points. We’ll implement this interpretation of the EM algorithm:</p>
<ul>
<li><strong>E-step</strong>: Assign each data point to the nearest cluster based on Euclidean distance.</li>
<li><strong>M-step</strong>: Update the cluster centers as the mean of the points assigned to each cluster.</li>
<li><strong>SSE</strong>: Compute the Sum of Squared Errors as the sum of squared Euclidean distances from each point to its assigned cluster center.</li>
<li><strong>Convergence</strong>: Stop when the L1-distance between old and new centers is less than 0.0001 or after 100 iterations.</li>
</ul>
<hr>
</section>
</section>
<section id="step-2-implementing-the-em-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="step-2-implementing-the-em-algorithm">Step 2: Implementing the EM Algorithm</h3>
<p>We’ll implement the algorithm in Python using NumPy and Pandas. Let’s go through the steps.</p>
<section id="step-2.1-load-and-preprocess-the-data" class="level4">
<h4 class="anchored" data-anchor-id="step-2.1-load-and-preprocess-the-data">Step 2.1: Load and Preprocess the Data</h4>
<p>First, we load the data from <code>Data_Q4.csv</code>.</p>
<div id="cell-3" class="cell" data-outputid="11ee186a-a771-423a-8617-9088284d29f0" data-execution_count="4">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>cd <span class="op">/</span>content<span class="op">/</span>drive<span class="op">/</span>MyDrive<span class="op">/</span>Notes<span class="op">/</span>MSBD5002<span class="op">/</span>Data_Q4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>/content/drive/MyDrive/Notes/MSBD5002/Data_Q4</code></pre>
</div>
</div>
<div id="cell-4" class="cell" data-outputid="c2907b79-ea4c-4836-e3fa-afa4f9187936" data-execution_count="8">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shutil</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the data</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_csv(<span class="st">'Q4_Data.csv'</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shape of data:"</span>, data.shape)  <span class="co"># Should be (626, 6)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to numpy array</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data.to_numpy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shape of data: (626, 6)</code></pre>
</div>
</div>
</section>
<section id="step-2.2-implement-the-em-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="step-2.2-implement-the-em-algorithm">Step 2.2: Implement the EM Algorithm</h4>
<p>We’ll define the EM algorithm with the specified initial centers, iterate until convergence, and track the centers and SSE for the first two iterations.</p>
<div id="cell-6" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the EM algorithm for clustering</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> em_clustering(X, initial_centers, max_iters<span class="op">=</span><span class="dv">100</span>, tol<span class="op">=</span><span class="fl">0.0001</span>):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    - X: Data array of shape (n_samples, n_features)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - initial_centers: Initial cluster centers of shape (n_clusters, n_features)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    - max_iters: Maximum number of iterations</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">    - tol: Tolerance for convergence (L1-distance)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - centers: Final cluster centers</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - iteration_logs: List of (centers, SSE) for each iteration</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    n_samples, n_features <span class="op">=</span> X.shape</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    n_clusters <span class="op">=</span> initial_centers.shape[<span class="dv">0</span>]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize centers</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    centers <span class="op">=</span> initial_centers.copy()</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    iteration_logs <span class="op">=</span> []</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(max_iters):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># E-step: Assign points to the nearest cluster</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        distances <span class="op">=</span> np.zeros((n_samples, n_clusters))</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_clusters):</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>            distances[:, k] <span class="op">=</span> np.<span class="bu">sum</span>((X <span class="op">-</span> centers[k]) <span class="op">**</span> <span class="dv">2</span>, axis<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Squared Euclidean distance</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> np.argmin(distances, axis<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Assign to nearest cluster</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute SSE (Sum of Squared Errors)</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        sse <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_clusters):</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            cluster_points <span class="op">=</span> X[labels <span class="op">==</span> k]</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(cluster_points) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>                sse <span class="op">+=</span> np.<span class="bu">sum</span>((cluster_points <span class="op">-</span> centers[k]) <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># M-step: Update cluster centers</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        new_centers <span class="op">=</span> np.zeros_like(centers)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_clusters):</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            cluster_points <span class="op">=</span> X[labels <span class="op">==</span> k]</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(cluster_points) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>                new_centers[k] <span class="op">=</span> np.mean(cluster_points, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>                new_centers[k] <span class="op">=</span> centers[k]  <span class="co"># If cluster is empty, keep the old center</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Log the centers and SSE for this iteration</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        iteration_logs.append((centers.copy(), sse))</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check for convergence using L1-distance</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        l1_distance <span class="op">=</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(new_centers <span class="op">-</span> centers))</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        centers <span class="op">=</span> new_centers</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> l1_distance <span class="op">&lt;</span> tol:</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Converged after </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> iterations"</span>)</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> iteration <span class="op">==</span> max_iters <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Reached maximum iterations (</span><span class="sc">{</span>max_iters<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> centers, iteration_logs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-7" class="cell" data-outputid="9cccbbda-815f-46d6-e7dd-163a382cde6e" data-execution_count="11">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial centers</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>initial_centers <span class="op">=</span> np.array([</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>],  <span class="co"># c1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.1</span>, <span class="fl">1.1</span>, <span class="fl">1.1</span>, <span class="fl">1.1</span>, <span class="fl">1.1</span>, <span class="fl">1.1</span>]   <span class="co"># c2</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the EM algorithm</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>final_centers, iteration_logs <span class="op">=</span> em_clustering(X, initial_centers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Converged after 11 iterations</code></pre>
</div>
</div>
<ul>
<li><strong>E-step</strong>: We compute the squared Euclidean distance from each point to each cluster center and assign the point to the nearest cluster.</li>
<li><strong>M-step</strong>: We update each cluster center as the mean of the points assigned to that cluster.</li>
<li><strong>SSE</strong>: We compute the Sum of Squared Errors as the sum of squared distances from each point to its assigned cluster center.</li>
<li><strong>Convergence</strong>: We check the L1-distance (sum of absolute differences) between the old and new centers and stop if it’s less than 0.0001 or after 100 iterations.</li>
<li><strong>Logging</strong>: We store the centers and SSE for each iteration to report the first two iterations.</li>
</ul>
</section>
<section id="step-2.3-report-the-results" class="level4">
<h4 class="anchored" data-anchor-id="step-2.3-report-the-results">Step 2.3: Report the Results</h4>
<p>We need to report: 1. The updated centers and SSE for the first two iterations. 2. The final centers when the algorithm converges.</p>
<div id="cell-9" class="cell" data-outputid="9ad7ca3b-085b-4bc5-eeb9-acce042e3ce3" data-execution_count="12">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Report the updated centers and SSE for the first two iterations</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"First Iteration:"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Centers:"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c1:"</span>, iteration_logs[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c2:"</span>, iteration_logs[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SSE:"</span>, iteration_logs[<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Second Iteration:"</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Centers:"</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c1:"</span>, iteration_logs[<span class="dv">1</span>][<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c2:"</span>, iteration_logs[<span class="dv">1</span>][<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SSE:"</span>, iteration_logs[<span class="dv">1</span>][<span class="dv">1</span>])</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Report the final centers</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Final Centers:"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c1:"</span>, final_centers[<span class="dv">0</span>])</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"c2:"</span>, final_centers[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>First Iteration:
Centers:
c1: [0. 0. 0. 0. 0. 0.]
c2: [1.1 1.1 1.1 1.1 1.1 1.1]
SSE: 530541.02

Second Iteration:
Centers:
c1: [1.44444444 0.22222222 0.66666667 0.         0.         0.11111111]
c2: [ 2.84602917  6.42139384 14.31604538  8.99351702  0.24311183  1.01620746]
SSE: 325470.1898978879

Final Centers:
c1: [2.52037037 4.6037037  9.33888889 5.17037037 0.22222222 0.95      ]
c2: [ 4.74418605 17.18604651 44.13953488 32.05813953  0.34883721  1.3372093 ]</code></pre>
</div>
</div>
<ul>
<li>The <code>iteration_logs</code> list contains tuples of (centers, SSE) for each iteration. We access the first two entries for the first two iterations.</li>
<li>The <code>final_centers</code> variable contains the centers after convergence.</li>
</ul>
</section>
<section id="step-2.4-package-the-submission" class="level4">
<h4 class="anchored" data-anchor-id="step-2.4-package-the-submission">Step 2.4: Package the Submission</h4>
<p>We need to submit the code and report in a folder named <code>Q4</code>. The report (<code>Q4_readme.pdf</code>) should include the updated centers and SSE for the first two iterations, the final centers, and the code.</p>
<ul>
<li><strong>Note</strong>: The question asks for <code>Q4_readme.pdf</code>, so you’ll need to convert the code and report to PDF format manually (e.g., by copying the code and output into a document and saving as PDF).</li>
</ul>
<hr>
</section>
</section>
<section id="step-3-write-the-report" class="level3">
<h3 class="anchored" data-anchor-id="step-3-write-the-report">Step 3: Write the Report</h3>
<p>The report should include the updated centers and SSE for the first two iterations, the final centers, and the code. Here’s a summary to include in <code>Q4_readme.pdf</code>:</p>
<section id="report-content" class="level4">
<h4 class="anchored" data-anchor-id="report-content">Report Content</h4>
<ol type="1">
<li><p><strong>Introduction</strong>:</p>
<ul>
<li>The task is to implement the Expectation-Maximization (EM) algorithm for clustering the data in <code>Q4_Data.csv</code> into two clusters (c1 and c2).</li>
<li>The dataset contains 626 instances with 6 attributes.</li>
<li>Initial centers:
<ul>
<li>c1 = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0)</li>
<li>c2 = (1.1, 1.1, 1.1, 1.1, 1.1, 1.1)</li>
</ul></li>
</ul></li>
<li><p><strong>Algorithm Description</strong>:</p>
<ul>
<li><strong>E-step</strong>: Assign each data point to the nearest cluster based on Euclidean distance.</li>
<li><strong>M-step</strong>: Update the cluster centers as the mean of the points assigned to each cluster.</li>
<li><strong>SSE</strong>: Compute the Sum of Squared Errors as the sum of squared distances from each point to its assigned cluster center.</li>
<li><strong>Convergence</strong>: Stop when the L1-distance between old and new centers is less than 0.0001 or after 100 iterations.</li>
</ul></li>
<li><p><strong>Results</strong>:</p>
<ul>
<li><strong>First Iteration</strong>:
<ul>
<li>Centers:
<ul>
<li>c1: [Output from iteration_logs[0][0][0]]</li>
<li>c2: [Output from iteration_logs[0][0][1]]</li>
</ul></li>
<li>SSE: [Output from iteration_logs[0][1]]</li>
</ul></li>
<li><strong>Second Iteration</strong>:
<ul>
<li>Centers:
<ul>
<li>c1: [Output from iteration_logs[1][0][0]]</li>
<li>c2: [Output from iteration_logs[1][0][1]]</li>
</ul></li>
<li>SSE: [Output from iteration_logs[1][1]]</li>
</ul></li>
<li><strong>Final Centers</strong>:
<ul>
<li>c1: [Output from final_centers[0]]</li>
<li>c2: [Output from final_centers[1]]</li>
</ul></li>
</ul></li>
<li><p><strong>Code</strong>:</p>
<ul>
<li>[Include the entire code from above]</li>
</ul></li>
</ol>
<hr>
</section>
</section>
<section id="final-submission" class="level3">
<h3 class="anchored" data-anchor-id="final-submission">Final Submission</h3>
<p>Your submission folder <code>Q4</code> should contain: - <code>Q4_readme.pdf</code>: The report with the code, updated centers, and SSE for the first two iterations, and the final centers.</p>
<p><strong>Folder Structure</strong>:</p>
<pre><code>Q4/
└── Q4_readme.pdf</code></pre>
<p>To create the PDF:</p>
<ol type="1">
<li>Copy the report content above into a document editor.</li>
<li>Include the actual output (centers and SSE) from running the code.</li>
<li>Format it for clarity (e.g., use headings, bullet points).</li>
<li>Export the document as a PDF named <code>Q4_readme.pdf</code>.</li>
<li>Place the PDF in the <code>Q4</code> folder.</li>
</ol>
<hr>
</section>
<section id="notes-and-potential-improvements" class="level3">
<h3 class="anchored" data-anchor-id="notes-and-potential-improvements">Notes and Potential Improvements</h3>
<ol type="1">
<li><strong>EM vs.&nbsp;K-Means</strong>: The problem uses EM terminology but describes a k-means-like algorithm. A true EM algorithm for clustering would involve Gaussian Mixture Models (GMMs) with soft assignments (probabilities), covariance matrices, and maximization of the likelihood. If the problem intended a GMM, we’d need to modify the implementation to include these components.</li>
<li><strong>Empty Clusters</strong>: The code handles empty clusters by keeping the old center, but in a real scenario, you might reinitialize the center randomly.</li>
<li><strong>Data Preprocessing</strong>: The problem doesn’t specify preprocessing, but in practice, you might normalize the data if the features have different scales.</li>
</ol>
</section>
</section>
<section id="end" class="level1">
<h1>END</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/twtang\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>